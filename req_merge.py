import os
import logging
from datetime import datetime
from typing import List, Optional

input_dir = "dependencies"
output_file = "output.txt"
prioritize_unversioned = True
soft_errors = True

class DependencyManager:
    def __init__(self, input_path: str, output_file: str, prioritize_unversioned: bool = False, soft_errors: bool = False):
        """
        Initializes the DependencyManager object.

        Args:
        input_path (str): Path to the directory or input file(s).
        output_file (str): Path to the output file.
        prioritize_unversioned (bool, optional): Whether to prioritize unversioned libraries. Defaults to False.
        soft_errors (bool, optional): Whether to avoid failure on libraries without versions. Defaults to False.
        """
        self.input_path = input_path
        self.output_file = output_file
        self.prioritize_unversioned = prioritize_unversioned
        self.soft_errors = soft_errors
        self.dependencies = {}

    def run(self):
        """
        Runs the dependency manager to generate the output file.
        """
        logging.info("Starting Dependency Manager")
        self._get_input_files()
        self._parse_dependencies()
        self._write_output_file()
        logging.info("Dependency Manager finished")

    def _get_input_files(self):
        """
        Gets the list of input files from the input path.
        """
        if os.path.isdir(self.input_path):
            self.input_files = [os.path.join(self.input_path, f) for f in os.listdir(self.input_path) if os.path.isfile(os.path.join(self.input_path, f))]
        elif os.path.isfile(self.input_path):
            self.input_files = [self.input_path]
        else:
            raise ValueError("Input path does not exist or is not a file or directory")

    def _parse_dependencies(self):
        """
        Parses the input files to generate a dictionary of dependencies.
        """
        for input_file in self.input_files:
            logging.info(f"Parsing {input_file}")
            with open(input_file, 'r') as f:
                for line in f.readlines():
                    line = line.strip()
                    if line.startswith("#") or not line:
                        continue
                    parts = line.split('==')
                    if len(parts) < 2:
                        if self.soft_errors:
                            logging.warning(f"No version specified for {parts[0]} in {input_file}")
                            version = ""
                        else:
                            raise ValueError(f"No version specified for {parts[0]} in {input_file}")
                    else:
                        version = parts[1].strip()
                    library = parts[0].strip()
                    if library not in self.dependencies:
                        self.dependencies[library] = version
                    else:
                        if self.prioritize_unversioned and not self.dependencies[library]:
                            self.dependencies[library] = version
                        elif not self.prioritize_unversioned and version:
                            self.dependencies[library] = version

    def _write_output_file(self):
        """
        Writes the output file with the consolidated dependencies.
        """
        with open(self.output_file, 'w') as f:
            f.write("# Output file generated by DependencyManager\n")
            f.write("# Date: {}\n".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
            for library, version in sorted(self.dependencies.items()):
                f.write(f"{library}=={version}\n")


if __name__ == "__main__":
    logging.basicConfig(format='%(asctime)s %(levelname)s:%(message)s', level=logging.INFO)
    dm = DependencyManager(input_dir, output_file, prioritize_unversioned, soft_errors)
    dm.run()